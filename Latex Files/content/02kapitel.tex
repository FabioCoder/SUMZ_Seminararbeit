%!TEX root = ../dokumentation.tex

\chapter{Grundlagen}
\vskip -3em
\textbf{Autor: Sebastian Greulich}

Dieses Kapitel hat das Ziel ein allgemeines Verständnis von Webframeworks, Webarchitekturen und JavaScript mit seinen Erweiterungen und Obermengen (TypeScript, JSX) zu vermitteln. Zuerst werden in \autoref{sec:webframeworks} Webframeworks im Allgemeinen vorgestellt. Im Anschluss daran werden Black-Box- und White-Box-Frameworks miteinander verglichen und die allgemeinen Vor- und Nachteile von Frameworks beschrieben. Nach den Webframeworks werden in \autoref{sec:webarchitekturen} verschiedene Architekturmöglichkeiten im Webumfeld erläutert, dazu gehören unter anderem das MVC-Modell und Single-Page-Applikationen. Den Abschluss des Grundlagenkapitels bildet \autoref{sec:js}, eine Vorstellung der Websprache JavaScript und der Weiterentwicklung von ihr: TypeScript. 

%Übersetzer
\section{Webframeworks}\label{sec:webframeworks}

\subsection{Allgemeines}

Webframeworks bilden die Rahmenstruktur für clientseitige Oberflächenentwicklungen. Sie sind eine Sammlung von Methoden, welche Funktionalitäten durch einen Methodenaufruf ermöglichen und somit die Struktur der Oberflächen bestimmen. Webframeworks haben sich aufgrund ihrer einfachen Implementierung etabliert. Mit dem Einsatz von Webframeworks muss der Entwickler nicht Experte in jedem Teilgebiet seiner Entwicklung sein, sondern kann schon vorgefertigte und getestete Elemente übernehmen und spezielle Funktionalitäten von ihnen nutzen. Beispielsweise nimmt das Weboberflächenframework \textit{bootstrap} dem Entwickler ab, sich um die Implementierung responsiver Fähigkeiten einer Webanwendung kümmern zu müssen.\autocites[vgl.][312\psqq]{Schatten2010}

Webframeworks nutzen hierbei ein Grundprinzip der Informatik: Die Wiederverwendung. Bei der Wiederverwendung wird es vermieden einen redundanten Quellcode zu schreiben. Dies bietet zahlreiche Vorteile: Zum einen muss sich der Entwickler nicht mehrmals die gleichen Gedankengänge zur selben Problemlösung machen, zum anderen kann er bei einem gefundenen Fehler anstatt bei jeder Verwendung einzeln, vielmehr nur an einer zentralen Stelle mit der Problembehebung ansetzen.\autocites[vgl.][302\psqq]{Schatten2010}

\subsection{Black-Box- und White-Box-Webframeworks}\label{sec:FWTypen}

Bei Frameworks unterscheidet man zwischen Black-Box- und White-Box-Frameworks. Bei einem \textbf{Black-Box-Framework} ist der Entwickler gezwungen sich auf vorgefertigte Methoden zu verlassen. Er kann das Framework einbinden, logische Veränderungen daran kann er aber nicht vornehmen. Bei einem \textbf{White-Box-Framework} stehen im Gegensatz dazu oftmals nur abstrakte oder leere Methoden zur Verfügung. Diese Methodenhülsen muss der Entwickler in seiner Software mit Inhalt füllen. Bei einem Vergleich dieser beiden Frameworkarten lässt sich feststellen, dass der Entwickler bei einem White-Box-Framework dieses im Ganzen verstanden haben muss um die „Lücken“ mit anwendungsfallspezifischen Code füllen zu können. Das Black-Box-Framework hingegen stellt eine Standardlösung dar, welche sich nicht näher auf den speziellen Anwendungsfall anpassen lässt, dafür aber nur eine geringe Einarbeitungszeit seitens des Entwicklers erfordert.\autocites[vgl.][2]{Kojarski2006}

\subsection{Vor- und Nachteile von Webframeworks}

Zum Abschluss des Kapitels „Webframeworks“ werden einige Vor- und Nachteile bei der Verwendung dieser kritisch beleuchtet, um dem Wesen der Webframeworks näherzukommen. 

Zuerst wird auf die Nachteile bei der Verwendung von Webframeworks eingegangen:

Jedes Framework hat einen hohen Grad an \textbf{Komplexität}. Diese ist zwar notwendig, um verschiedenen, teils komplexen Anforderungen gerecht zu werden, der Anwender muss die Funktionsweise des Frameworks jedoch zumindest teilweise verstanden haben um es effizient in seiner Entwicklung einsetzen zu können.

Bei der Nutzung eines Frameworks entstehen zwangsläufig \textbf{Abhängigkeiten} von diesem. Dies führt dazu, dass der Entwickler sich an eine bestimmte vorgegebene Architektur halten muss. Darüber hinaus muss der Frameworknutzer darauf vertrauen, dass der Frameworkentwickler seine Software ausreichend testet bevor er es an die Nutzer verteilt, ansonsten wäre die Funktionalität, auf welche der Entwickler vertraut, nicht gewährleistet.

Viele Frameworks (oft im Open-Source-Umfeld) leiden häufig an \textbf{mangelnder Dokumentation}. Dies erschwert es dem Entwickler, sich in das Framework einzuarbeiten und es von Beginn an effizient nutzen zu können.

Komplexität und Abhängigkeit können einerseits wie beschrieben nachteilig bewertet werden, andererseits kann durch das umfangreiche Funktionsangebot sehr viel Zeit und Aufwand gespart werden. Auf jene Vorteile wird in Folgendem eingegangen.

Ein Framework wird normalerweise im objektorientierten Umfeld genutzt. Somit gibt es dem Entwickler schon ein bestimmtes \textbf{Architekturmuster} vor, welches ihn dazu verleitet, seine Webanwendung modular und nicht nach Belieben aufzubauen.

Aufgrund der Generik eines Webframeworks ist es möglich dieses für viele verschiedene Anwendungsfälle \textbf{wiederzuverwenden}. Damit spart sich der Entwickler wertvolle Zeit und Aufwand.

Webframeworks sind auf \textbf{Erweiterbarkeit} ausgelegt. Man kann den Quellcode von den meisten Frameworks untersuchen sowie beliebig verändern und erweitern. Dies bietet den Vorteil, falls man als Entwickler einen anderen Datentyp benötigt oder in eine Funktion einen weiteren Parameter hinzufügen möchte, das Framework an die speziellen Bedürfnisse anpassen zu können.

Durch \textbf{Inversion of Control} bleibt der Kontrollfluss auf Seiten des Frameworks. Somit wird die Steuerung zur Ausführung bestimmter Unterprogramme an das Framework abgegeben und der Entwickler kann sich voll und ganz auf die Implementierung seiner Geschäftslogik konzentrieren.

Zuletzt ist der Vorteil durch \textbf{Standardisierung} anzuführen. Bestimmte Frameworks haben sich in ihrem Umfeld zum Standard entwickelt. Die Frameworkstandardisierung verkürzt die Einarbeitungszeit von Entwicklern in diesem Umfeld, da wiederholt aufkommende Herausforderungen immer auf dieselbe Weise gelöst werden können.\autocites[vgl.][313\psqq]{Schatten2010}


\section{Webarchitekturen}\label{sec:webarchitekturen}

\subsection{MVC-Modell}\label{MVC}
Das Entwurfsmuster MVC stammt aus den 1970er Jahren. Es wurde ursprünglich für Desktopanwendungen entwickelt, wird nun aber sowohl im Web, als auch bei mobilen Anwendungen verwendet. Die Idee hinter dem MVC-Konzept ist die Trennung von Bestandteilen einer Anwendung in jeweils eigene Verantwortlichkeiten. Somit erreicht man voneinander unabhängige Teile welche eigenständig und austauschbar sind. Mit dem MVC-Konzept vermeidet man darüber hinaus eine Vermischung von Aufgaben und der damit verbundenen Logik.\autocites[vgl.][7\psqq]{Steyer2017}

Der MVC-Ansatz umfasst 3 Komponenten: Die Erste davon ist das Model. Es steht für das zu präsentierende Datenmodell einer Anwendung. Die zweite Komponente stellt die View dar. Sie ist für die Präsentation der im Model enthaltenen Daten zuständig. In den Verantwortungsbereich der View fällt außerdem das Anzeigen von Benutzerinteraktionsmöglichkeiten wie beispielsweise ein Button. Die letzte Komponente bildet der Controller. Er bildet die Steuerungseinheit der Anwendung und kümmert sich um die Logik einer Applikation. Zu seinen Aufgaben gehört die Vermittlung zwischen dem Model und der View sowie der Interaktion mit dem Benutzer. Der Controller muss sicherstellen, dass alle Anpassungen in der View konsistent auf das Datenmodell angewandt werden.\autocites[vgl.][7\psqq]{Magnucki2017}

In älterer Software befinden sich das Model und der Controller typischerweise auf dem Server, bei neueren Entwicklungen werden diese beiden Komponenten jedoch direkt in den Browser geladen. Der Vorteil hierbei ist, dass der Internettraffic reduziert und die Performance der Anwendung erhöht wird.\autocites[vgl.][7\psqq]{Steyer2017}

\subsection{Single-Page-Applications}

Früher wurde bei jeder Interaktion eine Nachricht an den Server geschickt und eine neue Webseite als Antwort zurückgesendet. Dies war aufgrund von langsamen Browsern die einzige Möglichkeit um auf Benutzereingaben reagieren zu können. Im Laufe der Zeit wurden die Webbrowser immer performanter und damit wurde es komfortabel möglich, mittels JavaScript die Webseite ohne den Server zu verändern. 

Um das Jahr 2005 fing die Technologie AJAX (Asynchronous JavaScript and XML) an sich als Webkommunikationsstandard zu etablieren. Hierbei war die Technik, die AJAX zu Grunde liegt, nicht neu, denn es ist lediglich eine Kombination bestehender Technologien gepaart mit einer XMLHttpRequest. Durch AJAX wurde es somit möglich asynchrone Anfragen an den Webserver zu senden und die erhaltenen Daten in die bereits geöffnete Webseite zu integrieren. Nun war die Singe-Page-Application geboren. Das Grundgerüst einer Webseite musste bei dieser Technik nur beim initialen Aufruf geladen werden. Heutzutage nutzen fast alle Webframeworks die AJAX-Technik um die Ladezeiten der Webseiten zu verkürzen, falls nur kleine Änderungen vorliegen. Ein weiterer Vorteil ergibt sich zudem durch die Asynchronität. Falls eine schlechte Internetverbindung vorliegt zeigt der Browser während der Ladezeit nicht eine weiße Ladeseite, der Benutzer kann die Webinhalte somit weiter konsumieren.\autocites[vgl.][4]{Fink2014}[vgl.][7\psqq]{Jaeger2008}

\subsection{Websockets}

Mit den bisher beschriebenen Technologien musste der Client immer eine Anfrage an den Server schicken. Bei bestimmten Anwendungsfällen ist aber eine persistente und bidirektionale Verbindung zum Server notwendig. Beispielsweise will man bei Chat-Anwendungen oder Live-Sport-Tickern immer in Echtzeit die aktuellen Informationen bereitgestellt bekommen. Die bisher gängigen HTTP-Verbindungen sehen diese Art der Verbindung jedoch nicht vor. Auf ihrer Basis müsste der Benutzer die Webseite immer manuell aktualisieren. Mittels eines Websockets kann eine solche persistente Client-Server-Verbindung geöffnet werden. Ein Websocket basiert auf einem eigenen Protokoll, dieses muss zuerst über HTTP-Anfragen verhandelt werden. Wenn Client und Server der Verbindung zugestimmt haben besteht zwischen den beiden Parteien ein dauerhafter „Tunnel“. Über diesen können Informationen mit geringer Latenz ausgetauscht werden. Im Vergleich zu einer herkömmlichen HTTP-Verbindung wird der überflüssige Header eingespart, dies führt zu weniger notwendigen Datenübertragungen. Wenn eine der beiden Parteien die dauerhafte Verbindung trennen möchte muss sie der Anderen eine „Close“-Nachricht senden.\autocites[vgl.][11\psqq]{Fink2014}

\section{JavaScript}\label{sec:js}
\vskip -1em
\textbf{Autor: Fabio Krämer}

Zur Entwicklung einer clientseitigen Anwendung wird die Skriptsprache JavaScript eingesetzt. Der Sprachstandard von JavaScript wird durch das  kontinuierlich weiterentwickelt ECMAScript spezifiziert. Durch die Verwendung der Obermenge TypeScript und der Spracherweiterung JSX kann die Entwicklung erleichtert und zudem können Funktionen, die nicht Teil des Sprachstandard von JavaScript sind, eingesetzt werden. Im Folgenden werden die mit JavaScript zusammenhängende Sprachen EcmaScript, TypeScript und JSX  näher erläutert.

\subsection{Der Sprachstandard ECMAScript}\label{sec:der-sprachstandard-ecmascript}
ECMAScript spezifiziert den Sprachstandard von JavaScript. Dieser wird seit dem Jahr 1997 Jahren von der European Computer Manufactures Association (kurz: ECMA) weiterentwickelt. Zunächst wurden die Versionen durchnummeriert (ES1, ES2, ES3, ES4, und ES5). Im Jahre 2015 wurde beschlossen, dass jährlich eine neue Version von ECMAScript erscheinen soll. Daher tragen die nachfolgenden Versionen das Veröffentlichungsjahr im Namen (ECMAScript2015, ECMAScript2016, ECMAScript2017, ECMAScript2018, …). 

Die neusten Browser unterstützen meist den aktuellsten ECMAScript Sprachstandard. Allerdings verwendet nicht jeder Benutzer einen neuen Browser. Um die Kompatibilität einer Webanwendung zu gewährleisten, muss der Code in eine von den meisten Browsern unterstütze Version transpiliert werden.\autocites[vgl.][27\psqq]{Woiwode.2018}[vgl.][]{Terlson.2018}[vgl.][13\psqq]{Steyer.2017}

Im Folgenden wird auf die, für die in \autoref{ch:angular},\ref{ch:reactJS} und \ref{ch:openUI5} vorgestellten Frameworks, relevantesten Sprachfeatures eingegangen.  

In ECMAScript2015 wurden die Variablentypen let zur Eingrenzung des Geltungsbereichs einer Variable und const zur Deklaration einer Konstanten eingeführt. Zudem können seit ECMAScript2015 auch Klassen und Module in JavaScript definiert werden. Eine Klasse kann mehrere Eigenschaften und Methoden enthalten. Zudem können Klassen voneinander erben.

Jede Datei ist ein eigenes Modul. Module fassen zusammengehörige Codeeinheiten zusammen und können Interfaces, Klassen oder Variablen bereitstellen, die wiederum von anderen Modulen verwendet werden können.\autocites[vgl.][34\psq]{Woiwode.2018}[vgl.][19\psqq]{Steyer.2017}


\label{Webpack}
%Modul-Loader
Wenn Java-Script Module in einer Webanwendung verwendet werden, wird ein Modul-Loader gebraucht. Dieser löst verschiedene Abhängigkeiten auf und erstellt daraus eine Ausgabedatei. Die Verwendung des Modul-Loader \textit{Webpack} wird sowohl für Angular als auch für React Anwendungen empfohlen. \textit{Webpack} unterstützt zudem Hot Module Replacement. Änderungen am Code werden zur Laufzeit übernommen. Dadurch muss eine Anwendung nach einer Änderung nicht komplett neu gebaut werden.\autocites[vgl.][13,21]{Woiwode.2018}[vgl.][9,295-301]{Zeigermann.2016}[vgl.][]{Hlushko.2018}

%Das Modul in \autoref{lst:ClassPerson} stellt eine Klasse Person zur Verfügung. Diese Klasse hat einen Konstruktor und eine Instanzmethode altere, die die Person um ein weiteres Jahr altern lässt.

%\begin{lstlisting}[caption=Eine Klasse Person wird von einem Modul bereitgestellt , label=lst:ClassPerson, language=Java]
%export class Person{
%   private name 	: string;
%   private alter 	: number;
%
%   constructor(name: string, alter: number){
%      this.name = name;
%      this.alter = alter;
%   }
%
%   altere(): number{
%      alter = alter + 1;
%      return alter;
%   }
%}
%\end{lstlisting}

Seit ECMAScript2017 können Dekoratoren für die Angabe von Metainformationen zu einer Klasse verwendet werden. Dies wird beispielsweise von dem in \autoref{ch:angular} vorgestellten Framwework Angular zur Kennzeichnung und Konfiguration der unterschiedlichen Bestandteile verwendet.\autocites[vgl.][30\psqq]{Woiwode.2018} 

\begin{figure}
	\centering
	\includegraphics[width=0.5\linewidth]{JavaScript.png}
	\caption{Beziehung zwischen ECMAScript und TypeScript} 
	\quelle{\textcite[28]{Woiwode.2018}}
	\label{fig:ECMAScript}
\end{figure}

\subsection{Die Obermenge TypeScript}\label{sec:ts}
TypeScript ist eine von Anders Hejlsberg bei Microsoft entwickelte Sprache. Diese erweitert die bestehende ECMAScript Version um weitere Sprachelemente und bildet somit eine Obermenge von JavaScript (siehe \autoref{fig:ECMAScript}). Ein Transpilierer übersetzt TypeScript in JavaScript. 

TypeScript ergänzt JavaScript unter anderem um ein stärkeres Typsystem. Hierdurch können Typfehler bereits zur Compilezeit erkannt und Tools zur Codeanalyse (automatische Codevervollständigung, Refactoring-Unterstützung, …) eingesetzt werden.\autocites[vgl.][27\psqq]{Woiwode.2018}[vgl.][13\psqq]{Steyer.2017}[vgl.][10]{Zeigermann.2016}TypeScript ermöglicht zudem die Verwendung von Interfaces. \autocites[vgl.][40\psq]{Woiwode.2018} 


Folgende Basisstypen stellt TypeScript zur Verfügung: \autocites[vgl.][34\psqq]{Woiwode.2018}[vgl.][16\psqq]{Steyer.2017}

\begin{itemize}
	\item  \textbf{number}: Ganz- oder Kommazahl
	\item \textbf{string}:  Zeichenkette
	\item \textbf{boolean}: Wahrheitswert
	\item \textbf{Array<typ>}: typisierte Arrays
	\item \textbf{any}: simuliert Standardverhalten von JavaScript  – beliebiger Datentyp
	\item \textbf{Function}: Funktion
\end{itemize}


\subsection{Die Erweiterung JSX}\label{sec:die-erweiterung-jsx}
\label{Babel}
Die Spracherweiterung JSX ermöglicht die Verwendung einer HTML ähnlichen Syntax in JavaScript. JSX wird durch einen geeigneten Transpilierer in gültiges JavaScript übersetzt.\textcite[vgl.][10]{Zeigermann.2016} empfiehlt an dieser Stelle die Verwendung des Compilers \textit{Babel}.

JSX wird unter anderem im Framework React zur Beschreibung einer Benutzeroberfläche eingesetzt. Die Benutzeroberfläche wird in React nicht unter Verwendung eines Templates, sondern über JavaScript-Befehle aufgebaut. Die Verwendung von JSX Ausdrücken anstatt JavaScript-Befehlen erleichtert diesen Vorgang. Im Folgenden werden die Grundkonzepte von JSX näher erläutert.

Die Ausgabe von dynamische Informationen erfolgt unter Verwendung von JavaScript-Ausdrücken. Diese Ausdrücke müssen in ein paar geschweifter Klammern gepackt werden. Bedingungen können mithilfe des ternären Operatoren überprüft werden. Zur Ausgabe von Listen mit wiederholenden Elementen steht die für Arrays definierte JavaScript Methode map zur Verfügung.

JSX bietet zudem die Möglichkeit das Aussehen eines Elements über das style-Attribut zu verändern. Das sytle-Attribut ist ein Objekt, daher wird die CSS-Eigenschaft und der zugehörige Wert als Objekt-Literal übergeben. Zudem ist zu beachten, dass die CamelCase-Notation für die CSS-Eigenschaften verwendet werden muss. In \autoref{lst:JSXBeispiel} wird die CSS-Eigenschaft \textit{color} und \textit{font-size} des HTML-Elements gesetzt.

Um XSS-Attacken zu verhindern, werden Strings in JSX automatisch escaped bzw. maskiert. Ein String wird demnach immer als Text interpretiert und dargestellt.\autocites[vgl.][59\psqq]{Zeigermann.2016}[vgl.][65\psqq]{Stefanov.2017} 

\begin{lstlisting}[caption=Beispiel für die Verwendung von JSX, label=lst:JSXBeispiel, language=HTML]
const titleColor = 'red';
const titleFontSize = 12;
const helloWorld = <h1 style = {{
color: titleColor,
fontSize: titleFontSize + 'px'
}}> Hello, World</h1>
\end{lstlisting}